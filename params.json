{"name":"OpenCLKit","tagline":"An Objective-C wrapper for the OpenCL C interface","body":"OpenCLKit\r\n=========\r\nOpenCLKit is a Objective-C wrapper around the OpenCL C interface. This Mac OS X framework is being developed as part of my PhD thesis on parallel algorithms in medical imaging.\r\n\r\nHow To\r\n------\r\nUsing OpenCLKit is straightforward if you have worked with OpenCL before. There \r\nis a small commented sample program in the `Examples` folder. The interesting part looks like this:\r\n```ObjC\r\n// Get the OpenCL platform. Multiple platforms may be availabe if more\r\n// than one OpenCL implementation is installed on this computer. The\r\n// same hardware device may also be availabe on multiple platforms.\r\nCLPlatform *platform = [CLPlatform platforms].firstObject;\r\n\r\n// Find a computing device. We will just choose the first OpenCL\r\n// compatible GPU that we can find in the platform. Other available\r\n// options include CL_DEVICE_TYPE_CPU and CL_DEVICE_TYPE_ALL. Note that\r\n// we should usually check if we actually found a device before using it\r\n// but this (like all error handling) is skipped here for brevity.\r\nCLDevice *GPUDevice = [platform devicesOfType:CL_DEVICE_TYPE_GPU].firstObject;\r\n\r\n// Create a context for our device. Contexts spanning multiple devices\r\n// are also possible.\r\nCLContext *context = [[CLContext alloc] initWithDevice:GPUDevice];\r\n\r\n// Load our OpenCL source code from a file and create an OpenCL program\r\n// from it. This will implicitly compile the program and create the\r\n// kernels.\r\nNSURL *sourceURL = [NSURL fileURLWithPath:@\"test.cl\"];\r\nCLProgram *program = [[CLProgram alloc] initWithContext:context URL:sourceURL];\r\n\r\n// A program consists of one or more kernels. While we can get a list of\r\n// all kernels of a program through its kernels property, we can also\r\n// access a kernel by its name.\r\nCLKernel *kernel = [program kernelNamed:@\"vector_add\"];\r\n\r\n// Get the kernel arguments. All arguments need to be passed explicitly\r\n// before the kernel can be run. Arguments can be accessed by name or\r\n// through the arguments property of the kernel. We will have a look at\r\n// all the arguments for our kernel.\r\nNSLog(@\"Arguments: %@\", kernel.arguments);\r\n\r\n// Our kernel sums two vectors and writes the result to a third one.\r\n// The source and target vectors are just plain C arrays of floats and\r\n// must all be of the same size. Note that a float on the device is a\r\n// cl_float on the host.\r\nconst NSUInteger vectorSize = 1e6;\r\nconst size_t vector_length = sizeof(cl_float) * vectorSize;\r\n\r\n// We just allocate enough memory and initialize it with random numbers\r\n// for this example. Data would usually be read in from a file anyway.\r\ncl_float *input_vector_a = malloc(vector_length);\r\ncl_float *input_vector_b = malloc(vector_length);\r\ncl_float *output_vector = malloc(vector_length);\r\nsrand48(arc4random());\r\n\r\nfor (NSUInteger i = 0; i < vectorSize; i++) {\r\n\tinput_vector_a[i] = drand48();\r\n\tinput_vector_b[i] = drand48();\r\n}\r\n\r\n// For use with OpenCLKit, data must be wrapped in a NSData container.\r\nNSData *inputVectorA = [NSData dataWithBytesNoCopy:input_vector_a length:vector_length freeWhenDone:YES];\r\n[kernel argumentNamed:@\"vec_a\"].data = inputVectorA;\r\n\r\nNSData *inputVectorB = [NSData dataWithBytesNoCopy:input_vector_b length:vector_length freeWhenDone:YES];\r\n[kernel argumentNamed:@\"vec_b\"].data = inputVectorB;\r\n\r\n// Since we want to write data back to our output vector, it must be of\r\n// the mutable subclass of NSData, NSMutableData.\r\nNSMutableData *outputVector = [NSMutableData dataWithBytesNoCopy:output_vector length:vector_length freeWhenDone:YES];\r\nCLKernelArgument *outputArgument = [kernel argumentNamed:@\"res\"];\r\noutputArgument.data = outputVector;\r\n\r\n// Passing arguments is straightforward. This will however not copy the\r\n// data to the device yet. Copying happens just in time right before the\r\n// kernel is executed on the device.\r\n[kernel argumentNamed:@\"res\"].data = outputVector;\r\n\r\n// Get the command queue for our device. While a context can contain\r\n// multiple devices, each device still has its own command queue. All\r\n// operations in a queue will be carried out in the same order they were\r\n// enqueued. This will ensure that we do not read results before the\r\n// calculations of a kernel are finished.\r\nCLCommandQueue *commandQueue = [context commandQueueForDevice:GPUDevice];\r\n\r\n// Run our kernel one million times, OpenCL will automatically determine\r\n// the parallelization.\r\nNSArray *dimensions = @[@(vectorSize)];\r\n[commandQueue enqueueKernel:program.kernels.firstObject globalDimensions:dimensions];\r\n\r\n// Read the output data. This method will not return until all kernels\r\n// in the queue have finished execution and data has been copied back to\r\n// the arguments backing NSData object.\r\n[commandQueue readDataForArgument:outputArgument];\r\n\r\n// Output data should now be available. We will just print out every\r\n// 10,000th entry of the vectors to check the sanity of our results.\r\nfor (NSUInteger i = 0; i < vectorSize; i += 10000) {\r\n\tNSLog(@\"%.2f + %.2f = %.2f\", input_vector_a[i], input_vector_b[i], ((cl_float *)outputArgument.data.bytes)[i]);\r\n}\r\n```\r\n\r\nDocumentation\r\n-------------\r\nIf [appledoc](https://github.com/tomaz/appledoc) is installed on your system in `/usr/local/bin/appledoc` you can use the `Documentation` build target to create a docset from the header files and install them for Xcode to use. Documentation is largely incomplete but should cover the most important bits to get started.\r\n\r\nLimitations\r\n-----------\r\nThere is only some basic functionality at the moment. Kernels taking constant values are currently not supported, neither are image data types or events. If you want to rely on OpenCLKit in your own applications, you will almost certainly need to add some functionality before being able to use it. Pull requests and issues are alway welcome.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}